// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// AccountsFeatures AccountsFeatures describes set of institution accounts features
//
// swagger:model AccountsFeatures
type AccountsFeatures struct {

	// AccountBalance holds list of data source identifiers which are capable to fetch account balance.
	// Required: true
	AccountBalance []SourceName `json:"balance"`

	// AccountCurrency holds list of data source identifiers which are capable to fetch account currency.
	// Required: true
	AccountCurrency []SourceName `json:"currency"`

	// AccountHolder holds list of data source identifiers which are capable to fetch account holder.
	// Required: true
	AccountHolder []SourceName `json:"accountHolder"`

	// AccountName holds list of data source identifiers which are capable to fetch account name.
	// Required: true
	AccountName []SourceName `json:"name"`

	// AccountNumber holds list of data source identifiers which are capable to fetch account number.
	// Required: true
	AccountNumber []SourceName `json:"accountNo"`

	// AvailableFunds holds list of data source identifiers which are capable to fetch available funds.
	// Required: true
	AvailableFunds []SourceName `json:"availableFunds"`

	// LastUpdated holds list of data source identifiers which are capable to fetch account last updated date.
	// Required: true
	LastUpdated []SourceName `json:"lastUpdated"`

	// Meta holds list of data source identifiers which are capable to fetch account meta data (e.g. mortgage data).
	// Required: true
	Meta []SourceName `json:"meta"`
}

// Validate validates this accounts features
func (m *AccountsFeatures) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAccountBalance(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAccountCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAccountHolder(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAccountName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAccountNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAvailableFunds(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLastUpdated(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMeta(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AccountsFeatures) validateAccountBalance(formats strfmt.Registry) error {

	if err := validate.Required("balance", "body", m.AccountBalance); err != nil {
		return err
	}

	for i := 0; i < len(m.AccountBalance); i++ {

		if err := m.AccountBalance[i].Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("balance" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *AccountsFeatures) validateAccountCurrency(formats strfmt.Registry) error {

	if err := validate.Required("currency", "body", m.AccountCurrency); err != nil {
		return err
	}

	for i := 0; i < len(m.AccountCurrency); i++ {

		if err := m.AccountCurrency[i].Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("currency" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *AccountsFeatures) validateAccountHolder(formats strfmt.Registry) error {

	if err := validate.Required("accountHolder", "body", m.AccountHolder); err != nil {
		return err
	}

	for i := 0; i < len(m.AccountHolder); i++ {

		if err := m.AccountHolder[i].Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("accountHolder" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *AccountsFeatures) validateAccountName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.AccountName); err != nil {
		return err
	}

	for i := 0; i < len(m.AccountName); i++ {

		if err := m.AccountName[i].Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("name" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *AccountsFeatures) validateAccountNumber(formats strfmt.Registry) error {

	if err := validate.Required("accountNo", "body", m.AccountNumber); err != nil {
		return err
	}

	for i := 0; i < len(m.AccountNumber); i++ {

		if err := m.AccountNumber[i].Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("accountNo" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *AccountsFeatures) validateAvailableFunds(formats strfmt.Registry) error {

	if err := validate.Required("availableFunds", "body", m.AvailableFunds); err != nil {
		return err
	}

	for i := 0; i < len(m.AvailableFunds); i++ {

		if err := m.AvailableFunds[i].Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("availableFunds" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *AccountsFeatures) validateLastUpdated(formats strfmt.Registry) error {

	if err := validate.Required("lastUpdated", "body", m.LastUpdated); err != nil {
		return err
	}

	for i := 0; i < len(m.LastUpdated); i++ {

		if err := m.LastUpdated[i].Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("lastUpdated" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *AccountsFeatures) validateMeta(formats strfmt.Registry) error {

	if err := validate.Required("meta", "body", m.Meta); err != nil {
		return err
	}

	for i := 0; i < len(m.Meta); i++ {

		if err := m.Meta[i].Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("meta" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *AccountsFeatures) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AccountsFeatures) UnmarshalBinary(b []byte) error {
	var res AccountsFeatures
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
